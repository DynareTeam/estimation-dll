/*
 * Copyright (C) 2010 Dynare Team
 *
 * This file is part of Dynare.
 *
 * Dynare is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Dynare is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _MATRIX_HH
#define _MATRIX_HH

#include <algorithm>
#include <iostream>
#include <iomanip>

#include <cstdlib>
#include <cassert>
#include <cstring>
#include <cmath>

#include "Vector.hh"

/*
  This header defines three matrix classes, which implement a "matrix concept"
  (much like the concepts of the Standard Template Library or of Boost
  Library). The first class is a matrix owning the data space for its
  elements, and the other two are matrix "views" of another matrix, i.e. a
  contiguous submatrix. This design philosophy is close to the design of the
  GNU Scientific Library, but here using the syntactic power of C++ class and
  templates, while achieving very high efficiency.

  These classes can be used with various templated functions, including
  wrappers around the BLAS primitives.

  The expressions required to be valid for a class M implementing the "matrix concept" are:
  - M.getRows(): return number of rows
  - M.getCols(): return number of columns
  - M.getLd(): return the leading dimension (here the offset between two columns in the data space, since we are in column-major order)
  - M.getData(): return the pointer to the data space
  - M(i,j): get an element of the matrix

  The expressions required to be valid for a class M implementing the "mutable matrix concept" are (in addition to those of "matrix concept"):
  - M = X: assignment operator
  - M(i,j) = d: assign an element of the matrix
  - M.setAll(d): set all the elements of the matrix
*/

//! A full matrix, implements the "mutable matrix concept"
/*! Owns the data space for the elements */
class Matrix
{
 private:
  //! Stored in column-major order, as in Fortran and MATLAB
  double *data;
  const size_t rows, cols;
 public:
  Matrix(size_t rows_arg, size_t cols_arg);
  Matrix(size_t size_arg);
  Matrix(const Matrix &arg);
  virtual ~Matrix();
  inline size_t getRows() const { return rows; }
  inline size_t getCols() const { return cols; }
  inline size_t getLd() const { return rows; }
  inline double *getData() { return data; }
  inline const double *getData() const { return data; }
  inline void setAll(double val) { std::fill_n(data, rows*cols, val); }
  inline double &operator() (size_t i, size_t j) { return data[i+j*rows]; }
  inline const double &operator() (size_t i, size_t j) const { return data[i+j*rows]; }
  //! Assignment operator, only works for matrices of same dimension
  template<class Mat>
  Matrix &
  operator= (const Mat &arg)
  {
    assert(rows == arg.getRows() && cols == arg.getCols());
    for (size_t j = 0; j < cols; j++)
      memcpy(data + j*rows, arg.getData() + j*arg.getLd(), rows*sizeof(double));
    return *this;
  }
  //! The copy assignment operator, which is not generated by the template assignment operator
  /*! See C++ standard, ยง12.8.9, in the footnote */
  Matrix &operator= (const Matrix &arg);
};

//! A contiguous submatrix of another matrix, implements the "mutable matrix concept"
/*! Does not own the data space for the elements, so depends on another matrix */
class MatrixView
{
 private:
  double *const data;
  const size_t rows, cols, ld;
 public:
  MatrixView(double *data_arg, size_t rows_arg, size_t cols_arg, size_t ld_arg);
  MatrixView(Matrix &arg, size_t row_offset, size_t col_offset,
             size_t rows_arg, size_t cols_arg);
  virtual ~MatrixView(){};
  inline size_t getRows() const { return rows; }
  inline size_t getCols() const { return cols; }
  inline size_t getLd() const { return ld; }
  inline double *getData() { return data; }
  inline const double *getData() const { return data; }
  inline void setAll(double val)
  {
    for (double *p = data; p < data + cols*ld; p += ld)
      std::fill_n(p, rows, val);
  }
  inline double &operator() (size_t i, size_t j) { return data[i+j*ld]; }
  inline const double &operator() (size_t i, size_t j) const { return data[i+j*ld]; }
  //! Assignment operator, only works for matrices of same dimension
  template<class Mat>
  MatrixView &
  operator= (const Mat &arg)
  {
    assert(rows == arg.getRows() && cols == arg.getCols());
    for (size_t j = 0; j < cols; j++)
      memcpy(data + j*ld, arg.getData() + j*arg.getLd(), rows*sizeof(double));
    return *this;
  }
  //! The copy assignment operator, which is not generated by the template assignment operator
  /*! See C++ standard, ยง12.8.9, in the footnote */
  MatrixView &operator= (const MatrixView &arg);
};

//! Like MatrixView, but cannot be modified (implements the "matrix concept")
class MatrixConstView
{
 private:
  const double *const data;
  const size_t rows, cols, ld;
 public:
  MatrixConstView(const double *data_arg, size_t rows_arg, size_t cols_arg, size_t ld_arg);
  MatrixConstView(const Matrix &arg, size_t row_offset, size_t col_offset,
                  size_t rows_arg, size_t cols_arg);
  virtual ~MatrixConstView(){};
  inline size_t getRows() const { return rows; }
  inline size_t getCols() const { return cols; }
  inline size_t getLd() const { return ld; }
  inline const double *getData() const { return data; }
  inline const double &operator() (size_t i, size_t j) const { return data[i+j*ld]; }
};

std::ostream &operator<<(std::ostream &out, const Matrix &M);
std::ostream &operator<<(std::ostream &out, const MatrixView &M);
std::ostream &operator<<(std::ostream &out, const MatrixConstView &M);

namespace mat
{
  template<class Mat>
  void
  print(std::ostream &out, const Mat &M)
  {
    for(size_t i = 0; i < M.getRows(); i++)
      {
        for(size_t j = 0; j < M.getCols(); j++)
          out << std::setw(13) << std::right << M(i, j) << " ";
        out << std::endl;
      }
  }

  template<class Mat>
  inline VectorView
  get_col(Mat &M, size_t j)
  {
    return VectorView(M.getData()+j*M.getLd(), M.getRows(), 1);
  }

  template<class Mat>
  inline VectorView
  get_row(Mat &M, size_t i)
  {
    return VectorView(M.getData()+i, M.getCols(), M.getLd());
  }

  template<class Mat>
  inline VectorConstView
  get_col(const Mat &M, size_t j)
  {
    return VectorView(M.getData()+j*M.getLd(), M.getRows(), 1);
  }

  template<class Mat>
  inline VectorConstView
  get_row(const Mat &M, size_t i)
  {
    return VectorView(M.getData()+i, M.getCols(), M.getLd());
  }

  template<class Mat1, class Mat2>
  inline void
  col_copy(const Mat1 &src, size_t col_src, Mat2 &dest, size_t col_dest)
  {
    assert(src.getRows() == dest.getRows()
           && col_src < src.getCols() && col_dest < dest.getCols());
    memcpy(dest.getData() + col_dest*dest.getLd(),
           const_cast<double *>(src.getData()) + col_src*src.getLd(),
           src.getRows()*sizeof(double));
  }

  template<class Mat1, class Mat2>
  inline void
  col_copy(const Mat1 &src, size_t col_src, size_t row_offset_src, size_t row_nb,
           Mat2 &dest, size_t col_dest, size_t row_offset_dest)
  {
    assert(col_src < src.getCols() && col_dest < dest.getCols()
           && row_offset_src < src.getRows() && row_offset_src+row_nb <= src.getRows()
           && row_offset_dest < dest.getRows() && row_offset_dest+row_nb <= dest.getRows());
    memcpy(dest.getData() + row_offset_dest + col_dest*dest.getLd(),
           src.getData() + row_offset_src + col_src*src.getLd(),
           row_nb*sizeof(double));
  }

  template<class Mat1, class Mat2>
  inline void
  row_copy(const Mat1 &src, size_t row_src, Mat2 &dest, size_t row_dest)
  {
    assert(src.getCols() == dest.getCols()
           && row_src < src.getRows() && row_dest < dest.getRows());
    const double *p1 = src.getData() + row_src;
    double *p2 = dest.getData() + row_dest;
    while (p1 < src.getData() + src.getCols() * src.getLd())
      {
        *p2 = *p1;
        p1 += src.getLd();
        p2 += dest.getLd();
      }
  }

  template<class Mat>
  inline void
  col_set(Mat &M, size_t col, size_t row_offset, size_t row_nb, double val)
  {
    assert(col < M.getCols());
    assert(row_offset < M.getRows() && row_offset + row_nb <= M.getRows());
    std::fill_n(M.getData() + M.getLd()*col + row_offset, row_nb, val);
  }

  //! Copy under the diagonal the elements above the diagonal
  template<class Mat>
  inline void
  copy_upper_to_lower(Mat &M)
  {
    size_t d = std::min(M.getCols(), M.getRows());
    for (size_t i = 0; i < d; i++)
      for (size_t j = 0; j < i; j++)
        M(i, j) = M(j, i);
  }

  //! Copy above the diagonal the elements under the diagonal
  template<class Mat>
  inline void
  copy_lower_to_upper(Mat &M)
  {
    size_t d = std::min(M.getCols(), M.getRows());
    for (size_t i = 0; i < d; i++)
      for (size_t j = 0; j < i; j++)
        M(j, i) = M(i, j);
  }

  //! Fill the matrix with the identity matrix
  template<class Mat>
  inline void
  set_identity(Mat &M)
  {
    M.setAll(0.0);
    size_t d = std::min(M.getCols(), M.getRows());
    for (size_t i = 0; i < d; i++)
      M(i, i) = 1.0;
  }

  //! In-place transpose of a square matrix
  template<class Mat>
  inline void
  transpose(Mat &M)
  {
    assert(M.getRows() == M.getCols());
    for (size_t i = 0; i < M.getRows(); i++)
      for (size_t j = 0; j < i; j++)
        std::swap(M(i,j), M(j,i));
  }

  //! Computes M1 = M2' (even for rectangular matrices)
  template<class Mat1, class Mat2>
  inline void
  transpose(Mat1 &M1, const Mat2 &M2)
  {
    assert(M1.getRows() == M2.getCols() && M1.getCols() == M2.getRows());
    for (size_t i = 0; i < M1.getRows(); i++)
      for (size_t j = 0; j < M1.getCols(); j++)
        M1(i, j) = M2(j, i);
  }

  //! Computes m1 = m1 + m2
  template<class Mat1, class Mat2>
  void
  add(Mat1 &m1, const Mat2 &m2)
  {
    assert(m1.getRows() == m2.getRows() && m1.getCols() == m2.getCols());
    double *p1 = m1.getData();
    const double *p2 = m2.getData();
    while (p1 < m1.getData() + m1.getCols() * m1.getLd())
      {
        double *pp1 = p1;
        const double *pp2 = p2;
        while (pp1 < p1 + m1.getRows())
          *pp1++ += *pp2++;

        p1 += m1.getLd();
        p2 += m2.getLd();
      }
  }

  //! Computes m1 = m1 - m2
  template<class Mat1, class Mat2>
  void
  sub(Mat1 &m1, const Mat2 &m2)
  {
    assert(m1.getRows() == m2.getRows() && m1.getCols() == m2.getCols());
    double *p1 = m1.getData();
    const double *p2 = m2.getData();
    while (p1 < m1.getData() + m1.getCols() * m1.getLd())
      {
        double *pp1 = p1;
        const double *pp2 = p2;
        while (pp1 < p1 + m1.getRows())
          *pp1++ -= *pp2++;

        p1 += m1.getLd();
        p2 += m2.getLd();
      }
  }

  //! Does m = -m
  template<class Mat>
  void
  negate(Mat &m)
  {
    double *p = m.getData();
    while (p < m.getData() + m.getCols() * m.getLd())
      {
        double *pp = p;
        while (pp < p + m.getRows())
          {
            *pp = -*pp;
            pp++;
          }

        p += m.getLd();
      }
  }

  // Computes the infinite norm of a matrix
  template<class Mat>
  double
  nrminf(const Mat &m)
  {
    double nrm = 0;
    const double *p = m.getData();
    while (p < m.getData() + m.getCols() * m.getLd())
      {
        const double *pp = p;
        while (pp < p + m.getRows())
          {
            if (fabs(*pp) > nrm)
              nrm = fabs(*pp);
            pp++;
          }

        p += m.getLd();
      }
    return nrm;
  }
} // End of namespace

#endif
